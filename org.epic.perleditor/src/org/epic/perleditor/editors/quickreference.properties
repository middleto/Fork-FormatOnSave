chmod=    chmod LIST\n            Changes the permissions of a list of files. The first element of\n            the list must be the numerical mode, which should probably be an\n            octal number, and which definitely should *not* a string of\n            octal digits: 0644 is okay, '0644' is not. Returns the number of\n            files successfully changed. See also "oct", if all you have is a\n            string.
chomp=    chomp VARIABLE\n    chomp( LIST )\n    chomp   This safer version of "chop" removes any trailing string that\n            corresponds to the current value of $/ (also known as\n            $INPUT_RECORD_SEPARATOR in the "English" module). It returns the\n            total number of characters removed from all its arguments. It's\n            often used to remove the newline from the end of an input record\n            when you're worried that the final record may be missing its\n            newline. When in paragraph mode ("$/ = """), it removes all\n            trailing newlines from the string. When in slurp mode ("$/ =\n            undef") or fixed-length record mode ($/ is a reference to an\n            integer or the like, see perlvar) chomp() won't remove anything.\n            If VARIABLE is omitted, it chomps $_. Example:\n\n                while (<>) {\n                    chomp;  # avoid \\n on last field\n                    @array = split(/:/);\n                    # ...\n                }\n\n            If VARIABLE is a hash, it chomps the hash's values, but not its\n            keys.
chop=    chop VARIABLE\n    chop( LIST )\n    chop    Chops off the last character of a string and returns the\n            character chopped. It is much more efficient than "s/.$//s"\n            because it neither scans nor copies the string. If VARIABLE is\n            omitted, chops $_. If VARIABLE is a hash, it chops the hash's\n            values, but not its keys.
chown=    chown LIST\n            Changes the owner (and group) of a list of files. The first two\n            elements of the list must be the *numeric* uid and gid, in that\n            order. A value of -1 in either position is interpreted by most\n            systems to leave that value unchanged. Returns the number of\n            files successfully changed.
chr=    chr NUMBER\n    chr     Returns the character represented by that NUMBER in the\n            character set. For example, "chr(65)" is "A" in either ASCII or\n            Unicode, and chr(0x263a) is a Unicode smiley face. Note that\n            characters from 127 to 255 (inclusive) are by default not\n            encoded in Unicode for backward compatibility reasons (but see\n            encoding).
chroot=    chroot FILENAME\n    chroot  This function works like the system call by the same name: it\n            makes the named directory the new root directory for all further\n            pathnames that begin with a "/" by your process and all its\n            children. (It doesn't change your current working directory,\n            which is unaffected.) For security reasons, this call is\n            restricted to the superuser. If FILENAME is omitted, does a\n            "chroot" to $_.
close=    close FILEHANDLE\n    close   Closes the file or pipe associated with the file handle,\n            returning true only if IO buffers are successfully flushed and\n            closes the system file descriptor. Closes the currently selected\n            filehandle if the argument is omitted.
closedir=    closedir DIRHANDLE\n            Closes a directory opened by "opendir" and returns the success\n            of that system call.
connect=    connect SOCKET,NAME\n            Attempts to connect to a remote socket, just as the connect\n            system call does. Returns true if it succeeded, false otherwise.\n            NAME should be a packed address of the appropriate type for the\n            socket. See the examples in "Sockets: Client/Server\n            Communication" in perlipc.
cos=    cos EXPR\n    cos     Returns the cosine of EXPR (expressed in radians). If EXPR is\n            omitted, takes cosine of $_.
crypt=    crypt PLAINTEXT,SALT\n            Encrypts a string exactly like the crypt(3) function in the C\n            library (assuming that you actually have a version there that\n            has not been extirpated as a potential munition). This can prove\n            useful for checking the password file for lousy passwords,\n            amongst other things. Only the guys wearing white hats should do\n            this.
dbmclose=    dbmclose HASH\n            [This function has been largely superseded by the "untie"\n            function.]\n\n            Breaks the binding between a DBM file and a hash.
dbmopen=    dbmopen HASH,DBNAME,MASK\n            [This function has been largely superseded by the "tie"\n            function.]\n\n            This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB\n            file to a hash. HASH is the name of the hash. (Unlike normal\n            "open", the first argument is *not* a filehandle, even though it\n            looks like one). DBNAME is the name of the database (without the\n            .dir or .pag extension if any). If the database does not exist,\n            it is created with protection specified by MASK (as modified by\n            the "umask"). If your system supports only the older DBM\n            functions, you may perform only one "dbmopen" in your program.\n            In older versions of Perl, if your system had neither DBM nor\n            ndbm, calling "dbmopen" produced a fatal error; it now falls\n            back to sdbm(3).
defined=    defined EXPR\n    defined Returns a Boolean value telling whether EXPR has a value other\n            than the undefined value "undef". If EXPR is not present, $_\n            will be checked.
delete=    delete EXPR\n            Given an expression that specifies a hash element, array\n            element, hash slice, or array slice, deletes the specified\n            element(s) from the hash or array. In the case of an array, if\n            the array elements happen to be at the end, the size of the\n            array will shrink to the highest element that tests true for\n            exists() (or 0 if no such element exists).
die=    die LIST\n            Outside an "eval", prints the value of LIST to "STDERR" and\n            exits with the current value of $! (errno). If $! is 0, exits\n            with the value of "($? >> 8)" (backtick `command` status). If\n            "($? >> 8)" is 0, exits with 255. Inside an "eval()," the error\n            message is stuffed into $@ and the "eval" is terminated with the\n            undefined value. This makes "die" the way to raise an exception.
do=    do BLOCK\n            Not really a function. Returns the value of the last command in\n            the sequence of commands indicated by BLOCK. When modified by a\n            loop modifier, executes the BLOCK once before testing the loop\n            condition. (On other statements the loop modifiers test the\n            conditional first.)\n\n            "do BLOCK" does *not* count as a loop, so the loop control\n            statements "next", "last", or "redo" cannot be used to leave or\n            restart the block. See perlsyn for alternative strategies.
dump=    dump LABEL\n    dump    This function causes an immediate core dump. See also the -u\n            command-line switch in perlrun, which does the same thing.\n            Primarily this is so that you can use the undump program (not\n            supplied) to turn your core dump into an executable binary after\n            having initialized all your variables at the beginning of the\n            program. When the new binary is executed it will begin by\n            executing a "goto LABEL" (with all the restrictions that "goto"\n            suffers). Think of it as a goto with an intervening core dump\n            and reincarnation. If "LABEL" is omitted, restarts the program\n            from the top.
each=    each HASH\n            When called in list context, returns a 2-element list consisting\n            of the key and value for the next element of a hash, so that you\n            can iterate over it. When called in scalar context, returns only\n            the key for the next element in the hash.
eof=    eof FILEHANDLE\n    eof ()\n    eof     Returns 1 if the next read on FILEHANDLE will return end of\n            file, or if FILEHANDLE is not open. FILEHANDLE may be an\n            expression whose value gives the real filehandle. (Note that\n            this function actually reads a character and then "ungetc"s it,\n            so isn't very useful in an interactive context.) Do not read\n            from a terminal file (or call "eof(FILEHANDLE)" on it) after\n            end-of-file is reached. File types such as terminals may lose\n            the end-of-file condition if you do.
eval=    eval EXPR\n    eval BLOCK\n            In the first form, the return value of EXPR is parsed and\n            executed as if it were a little Perl program. The value of the\n            expression (which is itself determined within scalar context) is\n            first parsed, and if there weren't any errors, executed in the\n            lexical context of the current Perl program, so that any\n            variable settings or subroutine and format definitions remain\n            afterwards. Note that the value is parsed every time the eval\n            executes. If EXPR is omitted, evaluates $_. This form is\n            typically used to delay parsing and subsequent execution of the\n            text of EXPR until run time.
exec=    exec LIST\n    exec PROGRAM LIST\n            The "exec" function executes a system command *and never\n            returns*-- use "system" instead of "exec" if you want it to\n            return. It fails and returns false only if the command does not\n            exist *and* it is executed directly instead of via your system's\n            command shell (see below).
exists=    exists EXPR\n            Given an expression that specifies a hash element or array\n            element, returns true if the specified element in the hash or\n            array has ever been initialized, even if the corresponding value\n            is undefined. The element is not autovivified if it doesn't\n            exist.
exit=    exit EXPR\n            Evaluates EXPR and exits immediately with that value. Example:\n\n                $ans = <STDIN>;\n                exit 0 if $ans =~ /^[Xx]/;\n\n            See also "die". If EXPR is omitted, exits with 0 status. The\n            only universally recognized values for EXPR are 0 for success\n            and 1 for error; other values are subject to interpretation\n            depending on the environment in which the Perl program is\n            running. For example, exiting 69 (EX_UNAVAILABLE) from a\n            *sendmail* incoming-mail filter will cause the mailer to return\n            the item undelivered, but that's not true everywhere.
exp=    exp EXPR\n    exp     Returns *e* (the natural logarithm base) to the power of EXPR.\n            If EXPR is omitted, gives "exp($_)".
fcntl=    fcntl FILEHANDLE,FUNCTION,SCALAR\n            Implements the fcntl(2) function. You'll probably have to say\n\n                use Fcntl;\n\n            first to get the correct constant definitions. Argument\n            processing and value return works just like "ioctl" below. For\n            example:\n\n                use Fcntl;\n                fcntl($filehandle, F_GETFL, $packed_return_buffer)\n                    or die "can't fcntl F_GETFL: $!";\n\n            You don't have to check for "defined" on the return from\n            "fnctl". Like "ioctl", it maps a 0 return from the system call\n            into "0 but true" in Perl. This string is true in boolean\n            context and 0 in numeric context. It is also exempt from the\n            normal -w warnings on improper numeric conversions.
fileno=    fileno FILEHANDLE\n            Returns the file descriptor for a filehandle, or undefined if\n            the filehandle is not open. This is mainly useful for\n            constructing bitmaps for "select" and low-level POSIX\n            tty-handling operations. If FILEHANDLE is an expression, the\n            value is taken as an indirect filehandle, generally its name.
flock=    flock FILEHANDLE,OPERATION\n            Calls flock(2), or an emulation of it, on FILEHANDLE. Returns\n            true for success, false on failure. Produces a fatal error if\n            used on a machine that doesn't implement flock(2), fcntl(2)\n            locking, or lockf(3). "flock" is Perl's portable file locking\n            interface, although it locks only entire files, not records.
fork=    fork    Does a fork(2) system call to create a new process running the\n            same program at the same point. It returns the child pid to the\n            parent process, 0 to the child process, or "undef" if the fork\n            is unsuccessful. File descriptors (and sometimes locks on those\n            descriptors) are shared, while everything else is copied. On\n            most systems supporting fork(), great care has gone into making\n            it extremely efficient (for example, using copy-on-write\n            technology on data pages), making it the dominant paradigm for\n            multitasking over the last few decades.
format=    format  Declare a picture format for use by the "write" function. For\n            example:\n\n                format Something =\n                    Test: @<<<<<<<< @||||| @>>>>>\n                          $str,     $%,    '$' . int($num)\n                .
formline=    formline PICTURE,LIST\n            This is an internal function used by "format"s, though you may\n            call it, too. It formats (see perlform) a list of values\n            according to the contents of PICTURE, placing the output into\n            the format output accumulator, $^A (or $ACCUMULATOR in English).\n            Eventually, when a "write" is done, the contents of $^A are\n            written to some filehandle, but you could also read $^A yourself\n            and then set $^A back to "". Note that a format typically does\n            one "formline" per line of form, but the "formline" function\n            itself doesn't care how many newlines are embedded in the\n            PICTURE. This means that the "~" and "~~" tokens will treat the\n            entire PICTURE as a single line. You may therefore need to use\n            multiple formlines to implement a single record format, just\n            like the format compiler.
getc=    getc FILEHANDLE\n    getc    Returns the next character from the input file attached to\n            FILEHANDLE, or the undefined value at end of file, or if there\n            was an error. If FILEHANDLE is omitted, reads from STDIN. This\n            is not particularly efficient. However, it cannot be used by\n            itself to fetch single characters without waiting for the user\n            to hit enter. For that, try something more like:\n\n                if ($BSD_STYLE) {\n                    system "stty cbreak </dev/tty >/dev/tty 2>&1";\n                }\n                else {\n                    system "stty", '-icanon', 'eol', "\\001";\n                }\n\n                $key = getc(STDIN);\n\n                if ($BSD_STYLE) {\n                    system "stty -cbreak </dev/tty >/dev/tty 2>&1";\n                }\n                else {\n                    system "stty", 'icanon', 'eol', '^@'; # ASCII null\n                }\n                print "\\n";\n\n            Determination of whether $BSD_STYLE should be set is left as an\n            exercise to the reader.
getgrent=    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getgrgid=    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getgrnam=    getgrnam NAME\n    gethostbyname NAME\n    getnetbyname NAME\n    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
gethostbyaddr=    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
gethostbyname=    gethostbyname NAME\n    getnetbyname NAME\n    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
gethostent=    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getlogin=    getlogin\n            Implements the C library function of the same name, which on\n            most systems returns the current login from /etc/utmp, if any.\n            If null, use "getpwuid".
getnetbyaddr=    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getnetbyname=    getnetbyname NAME\n    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getnetent=    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getpeername=    getpeername SOCKET\n            Returns the packed sockaddr address of other end of the SOCKET\n            connection.
getpgrp=    getpgrp PID\n            Returns the current process group for the specified PID. Use a\n            PID of 0 to get the current process group for the current\n            process. Will raise an exception if used on a machine that\n            doesn't implement getpgrp(2). If PID is omitted, returns process\n            group of current process. Note that the POSIX version of\n            "getpgrp" does not accept a PID argument, so only "PID==0" is\n            truly portable.
getppid=    getppid Returns the process id of the parent process.
getpriority=    getpriority WHICH,WHO\n            Returns the current priority for a process, a process group, or\n            a user. (See getpriority(2).) Will raise a fatal exception if\n            used on a machine that doesn't implement getpriority(2).
getprotobyname=    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getprotobynumber=    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getprotoent=    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getpwnam=    getpwnam NAME\n    getgrnam NAME\n    gethostbyname NAME\n    getnetbyname NAME\n    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getpwuid=    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getservbyname=    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getservbyport=    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getservent=    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their counterparts\n            in the system library. In list context, the return values from\n            the various get routines are as follows:\n\n                ($name,$passwd,$uid,$gid,\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            The exact meaning of the $gcos field varies but it usually\n            contains the real name of the user (as opposed to the login\n            name) and other information pertaining to the user. Beware,\n            however, that in many system users are able to change this\n            information and therefore it cannot be trusted and therefore the\n            $gcos is tainted (see perlsec). The $passwd and $shell, user's\n            encrypted password and login shell, are also tainted, because of\n            the same reason.
getsockname=    getsockname SOCKET\n            Returns the packed sockaddr address of this end of the SOCKET\n            connection, in case you don't know the address because you have\n            several different IPs that the connection might have come in on.
getsockopt=    getsockopt SOCKET,LEVEL,OPTNAME\n            Returns the socket option requested, or undef if there is an\n            error.
glob=    glob EXPR\n    glob    In list context, returns a (possibly empty) list of filename\n            expansions on the value of EXPR such as the standard Unix shell\n            /bin/csh would do. In scalar context, glob iterates through such\n            filename expansions, returning undef when the list is exhausted.\n            This is the internal function implementing the "<*.c>" operator,\n            but you can use it directly. If EXPR is omitted, $_ is used. The\n            "<*.c>" operator is discussed in more detail in "I/O Operators"\n            in perlop.
gmtime=    gmtime EXPR\n            Converts a time as returned by the time function to an 8-element\n            list with the time localized for the standard Greenwich time\n            zone. Typically used as follows:\n\n                #  0    1    2     3     4    5     6     7\n                ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday) =\n                                                        gmtime(time);\n\n            All list elements are numeric, and come straight out of the C\n            `struct tm'. $sec, $min, and $hour are the seconds, minutes, and\n            hours of the specified time. $mday is the day of the month, and\n            $mon is the month itself, in the range 0..11 with 0 indicating\n            January and 11 indicating December. $year is the number of years\n            since 1900. That is, $year is 123 in year 2023. $wday is the day\n            of the week, with 0 indicating Sunday and 3 indicating\n            Wednesday. $yday is the day of the year, in the range 0..364 (or\n            0..365 in leap years.)\n\n            Note that the $year element is *not* simply the last two digits\n            of the year. If you assume it is, then you create\n            non-Y2K-compliant programs--and you wouldn't want to do that,\n            would you?\n\n            The proper way to get a complete 4-digit year is simply:\n\n                    $year += 1900;\n\n            And to get the last two digits of the year (e.g., '01' in 2001)\n            do:\n\n                    $year = sprintf("%02d", $year % 100);\n\n            If EXPR is omitted, "gmtime()" uses the current time\n            ("gmtime(time)").
grep=    grep BLOCK LIST\n    grep EXPR,LIST\n            This is similar in spirit to, but not the same as, grep(1) and\n            its relatives. In particular, it is not limited to using regular\n            expressions.
hex=    hex EXPR\n    hex     Interprets EXPR as a hex string and returns the corresponding\n            value. (To convert strings that might start with either 0, 0x,\n            or 0b, see "oct".) If EXPR is omitted, uses $_.
import=    import  There is no builtin "import" function. It is just an ordinary\n            method (subroutine) defined (or inherited) by modules that wish\n            to export names to another module. The "use" function calls the\n            "import" method for the package used. See also "use", perlmod,\n            and Exporter.
index=    index STR,SUBSTR,POSITION\n    index STR,SUBSTR\n            The index function searches for one string within another, but\n            without the wildcard-like behavior of a full regular-expression\n            pattern match. It returns the position of the first occurrence\n            of SUBSTR in STR at or after POSITION. If POSITION is omitted,\n            starts searching from the beginning of the string. The return\n            value is based at 0 (or whatever you've set the $[ variable\n            to--but don't do that). If the substring is not found, returns\n            one less than the base, ordinarily -1.
int=    int EXPR\n    int     Returns the integer portion of EXPR. If EXPR is omitted, uses\n            $_. You should not use this function for rounding: one because\n            it truncates towards 0, and two because machine representations\n            of floating point numbers can sometimes produce counterintuitive\n            results. For example, "int(-6.725/0.025)" produces -268 rather\n            than the correct -269; that's because it's really more like\n            -268.99999999999994315658 instead. Usually, the "sprintf",\n            "printf", or the "POSIX::floor" and "POSIX::ceil" functions will\n            serve you better than will int().
ioctl=    ioctl FILEHANDLE,FUNCTION,SCALAR\n            Implements the ioctl(2) function. You'll probably first have to\n            say\n\n                require "ioctl.ph"; # probably in /usr/local/lib/perl/ioctl.ph\n\n            to get the correct function definitions. If ioctl.ph doesn't\n            exist or doesn't have the correct definitions you'll have to\n            roll your own, based on your C header files such as\n            <sys/ioctl.h>. (There is a Perl script called h2ph that comes\n            with the Perl kit that may help you in this, but it's\n            nontrivial.) SCALAR will be read and/or written depending on the\n            FUNCTION--a pointer to the string value of SCALAR will be passed\n            as the third argument of the actual "ioctl" call. (If SCALAR has\n            no string value but does have a numeric value, that value will\n            be passed rather than a pointer to the string value. To\n            guarantee this to be true, add a 0 to the scalar before using\n            it.) The "pack" and "unpack" functions may be needed to\n            manipulate the values of structures used by "ioctl".
join=    join EXPR,LIST\n            Joins the separate strings of LIST into a single string with\n            fields separated by the value of EXPR, and returns that new\n            string. Example:\n\n                $rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);\n\n            Beware that unlike "split", "join" doesn't take a pattern as its\n            first argument. Compare "split".
keys=    keys HASH\n            Returns a list consisting of all the keys of the named hash. (In\n            scalar context, returns the number of keys.) The keys are\n            returned in an apparently random order. The actual random order\n            is subject to change in future versions of perl, but it is\n            guaranteed to be the same order as either the "values" or "each"\n            function produces (given that the hash has not been modified).\n            As a side effect, it resets HASH's iterator.
kill=    kill SIGNAL, LIST\n            Sends a signal to a list of processes. Returns the number of\n            processes successfully signaled (which is not necessarily the\n            same as the number actually killed).
last=    last LABEL\n    last    The "last" command is like the "break" statement in C (as used\n            in loops); it immediately exits the loop in question. If the\n            LABEL is omitted, the command refers to the innermost enclosing\n            loop. The "continue" block, if any, is not executed:\n\n                LINE: while (<STDIN>) {\n                    last LINE if /^$/;      # exit when done with header\n                    #...\n                }\n\n            "last" cannot be used to exit a block which returns a value such\n            as "eval {}", "sub {}" or "do {}", and should not be used to\n            exit a grep() or map() operation.
lc=    lc EXPR\n    lc      Returns a lowercased version of EXPR. This is the internal\n            function implementing the "\\L" escape in double-quoted strings.\n            Respects current LC_CTYPE locale if "use locale" in force. See\n            perllocale and perlunicode for more details about locale and\n            Unicode support.
lcfirst=    lcfirst EXPR\n    lcfirst Returns the value of EXPR with the first character lowercased.\n            This is the internal function implementing the "\\l" escape in\n            double-quoted strings. Respects current LC_CTYPE locale if "use\n            locale" in force. See perllocale and perlunicode for more\n            details about locale and Unicode support.
length=    length EXPR\n    length  Returns the length in characters of the value of EXPR. If EXPR\n            is omitted, returns length of $_. Note that this cannot be used\n            on an entire array or hash to find out how many elements these\n            have. For that, use "scalar @array" and "scalar keys %hash"\n            respectively.
link=    link OLDFILE,NEWFILE\n            Creates a new filename linked to the old filename. Returns true\n            for success, false otherwise.
listen=    listen SOCKET,QUEUESIZE\n            Does the same thing that the listen system call does. Returns\n            true if it succeeded, false otherwise. See the example in\n            "Sockets: Client/Server Communication" in perlipc.
local=    local EXPR\n            You really probably want to be using "my" instead, because\n            "local" isn't what most people think of as "local". See "Private\n            Variables via my()" in perlsub for details.
localtime=    localtime EXPR\n            Converts a time as returned by the time function to a 9-element\n            list with the time analyzed for the local time zone. Typically\n            used as follows:\n\n                #  0    1    2     3     4    5     6     7     8\n                ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =\n                                                            localtime(time);\n\n            All list elements are numeric, and come straight out of the C\n            `struct tm'. $sec, $min, and $hour are the seconds, minutes, and\n            hours of the specified time. $mday is the day of the month, and\n            $mon is the month itself, in the range 0..11 with 0 indicating\n            January and 11 indicating December. $year is the number of years\n            since 1900. That is, $year is 123 in year 2023. $wday is the day\n            of the week, with 0 indicating Sunday and 3 indicating\n            Wednesday. $yday is the day of the year, in the range 0..364 (or\n            0..365 in leap years.) $isdst is true if the specified time\n            occurs during daylight savings time, false otherwise.
log=    log EXPR\n    log     Returns the natural logarithm (base *e*) of EXPR. If EXPR is\n            omitted, returns log of $_. To get the log of another base, use\n            basic algebra: The base-N log of a number is equal to the\n            natural log of that number divided by the natural log of N. For\n            example:\n\n                sub log10 {\n                    my $n = shift;\n                    return log($n)/log(10);\n                }\n\n            See also "exp" for the inverse operation.
m=    m//     The match operator. See perlop.
map=    map BLOCK LIST\n    map EXPR,LIST\n            Evaluates the BLOCK or EXPR for each element of LIST (locally\n            setting $_ to each element) and returns the list value composed\n            of the results of each such evaluation. In scalar context,\n            returns the total number of elements so generated. Evaluates\n            BLOCK or EXPR in list context, so each element of LIST may\n            produce zero, one, or more elements in the returned value.
mkdir=    mkdir FILENAME,MASK\n    mkdir FILENAME\n            Creates the directory specified by FILENAME, with permissions\n            specified by MASK (as modified by "umask"). If it succeeds it\n            returns true, otherwise it returns false and sets $! (errno). If\n            omitted, MASK defaults to 0777.
msgctl=    msgctl ID,CMD,ARG\n            Calls the System V IPC function msgctl(2). You'll probably have\n            to say\n\n                use IPC::SysV;\n\n            first to get the correct constant definitions. If CMD is\n            "IPC_STAT", then ARG must be a variable which will hold the\n            returned "msqid_ds" structure. Returns like "ioctl": the\n            undefined value for error, "0 but true" for zero, or the actual\n            return value otherwise. See also "SysV IPC" in perlipc,\n            "IPC::SysV", and "IPC::Semaphore" documentation.
msgget=    msgget KEY,FLAGS\n            Calls the System V IPC function msgget(2). Returns the message\n            queue id, or the undefined value if there is an error. See also\n            "SysV IPC" in perlipc and "IPC::SysV" and "IPC::Msg"\n            documentation.
msgrcv=    msgrcv ID,VAR,SIZE,TYPE,FLAGS\n            Calls the System V IPC function msgrcv to receive a message from\n            message queue ID into variable VAR with a maximum message size\n            of SIZE. Note that when a message is received, the message type\n            as a native long integer will be the first thing in VAR,\n            followed by the actual message. This packing may be opened with\n            "unpack("l! a*")". Taints the variable. Returns true if\n            successful, or false if there is an error. See also "SysV IPC"\n            in perlipc, "IPC::SysV", and "IPC::SysV::Msg" documentation.
msgsnd=    msgsnd ID,MSG,FLAGS\n            Calls the System V IPC function msgsnd to send the message MSG\n            to the message queue ID. MSG must begin with the native long\n            integer message type, and be followed by the length of the\n            actual message, and finally the message itself. This kind of\n            packing can be achieved with "pack("l! a*", $type, $message)".\n            Returns true if successful, or false if there is an error. See\n            also "IPC::SysV" and "IPC::SysV::Msg" documentation.
my=    my EXPR\n    my TYPE EXPR\n    my EXPR : ATTRS\n    my TYPE EXPR : ATTRS\n            A "my" declares the listed variables to be local (lexically) to\n            the enclosing block, file, or "eval". If more than one value is\n            listed, the list must be placed in parentheses.
next=    next LABEL\n    next    The "next" command is like the "continue" statement in C; it\n            starts the next iteration of the loop:\n\n                LINE: while (<STDIN>) {\n                    next LINE if /^#/;      # discard comments\n                    #...\n                }\n\n            Note that if there were a "continue" block on the above, it\n            would get executed even on discarded lines. If the LABEL is\n            omitted, the command refers to the innermost enclosing loop.
no=    no Module VERSION LIST\n    no Module VERSION\n    no Module LIST\n    no Module\n            See the "use" function, which "no" is the opposite of.
oct=    oct EXPR\n    oct     Interprets EXPR as an octal string and returns the corresponding\n            value. (If EXPR happens to start off with "0x", interprets it as\n            a hex string. If EXPR starts off with "0b", it is interpreted as\n            a binary string. Leading whitespace is ignored in all three\n            cases.) The following will handle decimal, binary, octal, and\n            hex in the standard Perl or C notation:\n\n                $val = oct($val) if $val =~ /^0/;\n\n            If EXPR is omitted, uses $_. To go the other way (produce a\n            number in octal), use sprintf() or printf():\n\n                $perms = (stat("filename"))[2] & 07777;\n                $oct_perms = sprintf "%lo", $perms;\n\n            The oct() function is commonly used when a string such as 644\n            needs to be converted into a file mode, for example. (Although\n            perl will automatically convert strings into numbers as needed,\n            this automatic conversion assumes base 10.)\n\n
open=    open FILEHANDLE,EXPR\n    open FILEHANDLE,MODE,EXPR\n    open FILEHANDLE,MODE,EXPR,LIST\n    open FILEHANDLE,MODE,REFERENCE\n    open FILEHANDLE\n            Opens the file whose filename is given by EXPR, and associates\n            it with FILEHANDLE.
opendir=    opendir DIRHANDLE,EXPR\n            Opens a directory named EXPR for processing by "readdir",\n            "telldir", "seekdir", "rewinddir", and "closedir". Returns true\n            if successful. DIRHANDLEs have their own namespace separate from\n            FILEHANDLEs.
ord=    ord EXPR\n    ord     Returns the numeric (the native 8-bit encoding, like ASCII or\n            EBCDIC, or Unicode) value of the first character of EXPR. If\n            EXPR is omitted, uses $_.
pack=    pack TEMPLATE,LIST\n            Takes a LIST of values and converts it into a string using the\n            rules given by the TEMPLATE. The resulting string is the\n            concatenation of the converted values. Typically, each converted\n            value looks like its machine-level representation. For example,\n            on 32-bit machines a converted integer may be represented by a\n            sequence of 4 bytes.
package=    package NAMESPACE\n    package Declares the compilation unit as being in the given namespace.\n            The scope of the package declaration is from the declaration\n            itself through the end of the enclosing block, file, or eval\n            (the same as the "my" operator). All further unqualified dynamic\n            identifiers will be in this namespace. A package statement\n            affects only dynamic variables--including those you've used\n            "local" on--but *not* lexical variables, which are created with\n            "my". Typically it would be the first declaration in a file to\n            be included by the "require" or "use" operator. You can switch\n            into a package in more than one place; it merely influences\n            which symbol table is used by the compiler for the rest of that\n            block. You can refer to variables and filehandles in other\n            packages by prefixing the identifier with the package name and a\n            double colon: $Package::Variable. If the package name is null,\n            the "main" package as assumed. That is, $::sail is equivalent to\n            $main::sail (as well as to $main'sail, still seen in older\n            code).
pipe=    pipe READHANDLE,WRITEHANDLE\n            Opens a pair of connected pipes like the corresponding system\n            call. Note that if you set up a loop of piped processes,\n            deadlock can occur unless you are very careful. In addition,\n            note that Perl's pipes use IO buffering, so you may need to set\n            $| to flush your WRITEHANDLE after each command, depending on\n            the application.
pop=    pop ARRAY\n    pop     Pops and returns the last value of the array, shortening the\n            array by one element. Has an effect similar to\n\n                $ARRAY[$#ARRAY--]\n\n            If there are no elements in the array, returns the undefined\n            value (although this may happen at other times as well). If\n            ARRAY is omitted, pops the @ARGV array in the main program, and\n            the @_ array in subroutines, just like "shift".
pos=    pos SCALAR\n    pos     Returns the offset of where the last "m//g" search left off for\n            the variable in question ($_ is used when the variable is not\n            specified). May be modified to change that offset. Such\n            modification will also influence the "\\G" zero-width assertion\n            in regular expressions. See perlre and perlop.
print=    print FILEHANDLE LIST\n    print LIST\n    print   Prints a string or a list of strings. Returns true if\n            successful. FILEHANDLE may be a scalar variable name, in which\n            case the variable contains the name of or a reference to the\n            filehandle, thus introducing one level of indirection. (NOTE: If\n            FILEHANDLE is a variable and the next token is a term, it may be\n            misinterpreted as an operator unless you interpose a "+" or put\n            parentheses around the arguments.) If FILEHANDLE is omitted,\n            prints by default to standard output (or to the last selected\n            output channel--see "select"). If LIST is also omitted, prints\n            $_ to the currently selected output channel. To set the default\n            output channel to something other than STDOUT use the select\n            operation. The current value of $, (if any) is printed between\n            each LIST item. The current value of $\\ (if any) is printed\n            after the entire LIST has been printed. Because print takes a\n            LIST, anything in the LIST is evaluated in list context, and any\n            subroutine that you call will have one or more of its\n            expressions evaluated in list context. Also be careful not to\n            follow the print keyword with a left parenthesis unless you want\n            the corresponding right parenthesis to terminate the arguments\n            to the print--interpose a "+" or put parentheses around all the\n            arguments.
printf=    printf FILEHANDLE FORMAT, LIST\n    printf FORMAT, LIST\n            Equivalent to "print FILEHANDLE sprintf(FORMAT, LIST)", except\n            that $\\ (the output record separator) is not appended. The first\n            argument of the list will be interpreted as the "printf" format.\n            See "sprintf" for an explanation of the format argument. If "use\n            locale" is in effect, the character used for the decimal point\n            in formatted real numbers is affected by the LC_NUMERIC locale.\n            See perllocale.
prototype=    prototype FUNCTION\n            Returns the prototype of a function as a string (or "undef" if\n            the function has no prototype). FUNCTION is a reference to, or\n            the name of, the function whose prototype you want to retrieve.
push=    push ARRAY,LIST\n            Treats ARRAY as a stack, and pushes the values of LIST onto the\n            end of ARRAY. The length of ARRAY increases by the length of\n            LIST. Has the same effect as\n\n                for $value (LIST) {\n                    $ARRAY[++$#ARRAY] = $value;\n                }\n\n            but is more efficient. Returns the new number of elements in the\n            array.
q=    q/STRING/\n    qq/STRING/\n    qr/STRING/\n    qx/STRING/\n    qw/STRING/\n            Generalized quotes. See "Regexp Quote-Like Operators" in perlop.
quotemeta=    quotemeta EXPR\n    quotemeta\n            Returns the value of EXPR with all non-"word" characters\n            backslashed. (That is, all characters not matching\n            "/[A-Za-z_0-9]/" will be preceded by a backslash in the returned\n            string, regardless of any locale settings.) This is the internal\n            function implementing the "\\Q" escape in double-quoted strings.
rand=    rand EXPR\n    rand    Returns a random fractional number greater than or equal to 0\n            and less than the value of EXPR. (EXPR should be positive.) If\n            EXPR is omitted, the value 1 is used. Currently EXPR with the\n            value 0 is also special-cased as 1 - this has not been\n            documented before perl 5.8.0 and is subject to change in future\n            versions of perl. Automatically calls "srand" unless "srand" has\n            already been called. See also "srand".
read=    read FILEHANDLE,SCALAR,LENGTH,OFFSET\n    read FILEHANDLE,SCALAR,LENGTH\n            Attempts to read LENGTH *characters* of data into variable\n            SCALAR from the specified FILEHANDLE. Returns the number of\n            characters actually read, 0 at end of file, or undef if there\n            was an error. SCALAR will be grown or shrunk to the length\n            actually read. If SCALAR needs growing, the new bytes will be\n            zero bytes. An OFFSET may be specified to place the read data\n            into some other place in SCALAR than the beginning. The call is\n            actually implemented in terms of either Perl's or system's\n            fread() call. To get a true read(2) system call, see "sysread".
readdir=    readdir DIRHANDLE\n            Returns the next directory entry for a directory opened by\n            "opendir". If used in list context, returns all the rest of the\n            entries in the directory. If there are no more entries, returns\n            an undefined value in scalar context or a null list in list\n            context.
readline=    readline EXPR\n            Reads from the filehandle whose typeglob is contained in EXPR.\n            In scalar context, each call reads and returns the next line,\n            until end-of-file is reached, whereupon the subsequent call\n            returns undef. In list context, reads until end-of-file is\n            reached and returns a list of lines. Note that the notion of\n            "line" used here is however you may have defined it with $/ or\n            $INPUT_RECORD_SEPARATOR). See "$/" in perlvar.
readlink=    readlink EXPR\n    readlink\n            Returns the value of a symbolic link, if symbolic links are\n            implemented. If not, gives a fatal error. If there is some\n            system error, returns the undefined value and sets $! (errno).\n            If EXPR is omitted, uses $_.
readpipe=    readpipe EXPR\n            EXPR is executed as a system command. The collected standard\n            output of the command is returned. In scalar context, it comes\n            back as a single (potentially multi-line) string. In list\n            context, returns a list of lines (however you've defined lines\n            with $/ or $INPUT_RECORD_SEPARATOR). This is the internal\n            function implementing the "qx/EXPR/" operator, but you can use\n            it directly. The "qx/EXPR/" operator is discussed in more detail\n            in "I/O Operators" in perlop.
recv=    recv SOCKET,SCALAR,LENGTH,FLAGS\n            Receives a message on a socket. Attempts to receive LENGTH\n            characters of data into variable SCALAR from the specified\n            SOCKET filehandle. SCALAR will be grown or shrunk to the length\n            actually read. Takes the same flags as the system call of the\n            same name. Returns the address of the sender if SOCKET's\n            protocol supports this; returns an empty string otherwise. If\n            there's an error, returns the undefined value. This call is\n            actually implemented in terms of recvfrom(2) system call. See\n            "UDP: Message Passing" in perlipc for examples.
redo=    redo LABEL\n    redo    The "redo" command restarts the loop block without evaluating\n            the conditional again. The "continue" block, if any, is not\n            executed. If the LABEL is omitted, the command refers to the\n            innermost enclosing loop. This command is normally used by\n            programs that want to lie to themselves about what was just\n            input:\n\n                # a simpleminded Pascal comment stripper\n                # (warning: assumes no { or } in strings)\n                LINE: while (<STDIN>) {\n                    while (s|({.*}.*){.*}|$1 |) {}\n                    s|{.*}| |;\n                    if (s|{.*| |) {\n                        $front = $_;\n                        while (<STDIN>) {\n                            if (/}/) {      # end of comment?\n                                s|^|$front\\{|;\n                                redo LINE;\n                            }\n                        }\n                    }\n                    print;\n                }\n\n            "redo" cannot be used to retry a block which returns a value\n            such as "eval {}", "sub {}" or "do {}", and should not be used\n            to exit a grep() or map() operation.
ref=    ref EXPR\n    ref     Returns a true value if EXPR is a reference, false otherwise. If\n            EXPR is not specified, $_ will be used. The value returned\n            depends on the type of thing the reference is a reference to.\n            Builtin types include:\n\n                SCALAR\n                ARRAY\n                HASH\n                CODE\n                REF\n                GLOB\n                LVALUE\n\n            If the referenced object has been blessed into a package, then\n            that package name is returned instead. You can think of "ref" as\n            a "typeof" operator.
rename=    rename OLDNAME,NEWNAME\n            Changes the name of a file; an existing file NEWNAME will be\n            clobbered. Returns true for success, false otherwise.
require=    require VERSION\n    require EXPR\n    require Demands a version of Perl specified by VERSION, or demands some\n            semantics specified by EXPR or by $_ if EXPR is not supplied.
reset=    reset EXPR\n    reset   Generally used in a "continue" block at the end of a loop to\n            clear variables and reset "??" searches so that they work again.\n            The expression is interpreted as a list of single characters\n            (hyphens allowed for ranges). All variables and arrays beginning\n            with one of those letters are reset to their pristine state. If\n            the expression is omitted, one-match searches ("?pattern?") are\n            reset to match again. Resets only variables or searches in the\n            current package. Always returns 1. Examples:\n\n                reset 'X';          # reset all X variables\n                reset 'a-z';        # reset lower case variables\n                reset;              # just reset ?one-time? searches\n\n            Resetting "A-Z" is not recommended because you'll wipe out your\n            @ARGV and @INC arrays and your %ENV hash. Resets only package\n            variables--lexical variables are unaffected, but they clean\n            themselves up on scope exit anyway, so you'll probably want to\n            use them instead. See "my".
return=    return EXPR\n    return  Returns from a subroutine, "eval", or "do FILE" with the value\n            given in EXPR. Evaluation of EXPR may be in list, scalar, or\n            void context, depending on how the return value will be used,\n            and the context may vary from one execution to the next (see\n            "wantarray"). If no EXPR is given, returns an empty list in list\n            context, the undefined value in scalar context, and (of course)\n            nothing at all in a void context.
reverse=    reverse LIST\n            In list context, returns a list value consisting of the elements\n            of LIST in the opposite order. In scalar context, concatenates\n            the elements of LIST and returns a string value with all\n            characters in the opposite order.
rewinddir=    rewinddir DIRHANDLE\n            Sets the current position to the beginning of the directory for\n            the "readdir" routine on DIRHANDLE.
rindex=    rindex STR,SUBSTR,POSITION\n    rindex STR,SUBSTR\n            Works just like index() except that it returns the position of\n            the LAST occurrence of SUBSTR in STR. If POSITION is specified,\n            returns the last occurrence at or before that position.
rmdir=    rmdir FILENAME\n    rmdir   Deletes the directory specified by FILENAME if that directory is\n            empty. If it succeeds it returns true, otherwise it returns\n            false and sets $! (errno). If FILENAME is omitted, uses $_.
s=    s///    The substitution operator. See perlop.
scalar=    scalar EXPR\n            Forces EXPR to be interpreted in scalar context and returns the\n            value of EXPR.
seek=    seek FILEHANDLE,POSITION,WHENCE\n            Sets FILEHANDLE's position, just like the "fseek" call of\n            "stdio". FILEHANDLE may be an expression whose value gives the\n            name of the filehandle. The values for WHENCE are 0 to set the\n            new position *in bytes* to POSITION, 1 to set it to the current\n            position plus POSITION, and 2 to set it to EOF plus POSITION\n            (typically negative). For WHENCE you may use the constants\n            "SEEK_SET", "SEEK_CUR", and "SEEK_END" (start of the file,\n            current position, end of the file) from the Fcntl module.\n            Returns 1 upon success, 0 otherwise.
seekdir=    seekdir DIRHANDLE,POS\n            Sets the current position for the "readdir" routine on\n            DIRHANDLE. POS must be a value returned by "telldir". Has the\n            same caveats about possible directory compaction as the\n            corresponding system library routine.
select=    select FILEHANDLE\n    select  Returns the currently selected filehandle. Sets the current\n            default filehandle for output, if FILEHANDLE is supplied. This\n            has two effects: first, a "write" or a "print" without a\n            filehandle will default to this FILEHANDLE. Second, references\n            to variables related to output will refer to this output\n            channel. For example, if you have to set the top of form format\n            for more than one output channel, you might do the following:\n\n                select(REPORT1);\n                $^ = 'report1_top';\n                select(REPORT2);\n                $^ = 'report2_top';\n\n            FILEHANDLE may be an expression whose value gives the name of\n            the actual filehandle. Thus:\n\n                $oldfh = select(STDERR); $| = 1; select($oldfh);\n\n            Some programmers may prefer to think of filehandles as objects\n            with methods, preferring to write the last example as:\n\n                use IO::Handle;\n                STDERR->autoflush(1);\n\n    select RBITS,WBITS,EBITS,TIMEOUT\n            This calls the select(2) system call with the bit masks\n            specified, which can be constructed using "fileno" and "vec",\n            along these lines:\n\n                $rin = $win = $ein = '';\n                vec($rin,fileno(STDIN),1) = 1;\n                vec($win,fileno(STDOUT),1) = 1;\n                $ein = $rin | $win;\n\n            If you want to select on many filehandles you might wish to\n            write a subroutine:\n\n                sub fhbits {\n                    my(@fhlist) = split(' ',$_[0]);\n                    my($bits);\n                    for (@fhlist) {\n                        vec($bits,fileno($_),1) = 1;\n                    }\n                    $bits;\n                }\n                $rin = fhbits('STDIN TTY SOCK');\n\n            The usual idiom is:\n\n                ($nfound,$timeleft) =\n                  select($rout=$rin, $wout=$win, $eout=$ein, $timeout);\n\n            or to block until something becomes ready just do this\n\n                $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);\n\n            Most systems do not bother to return anything useful in\n            $timeleft, so calling select() in scalar context just returns\n            $nfound.
semctl=    semctl ID,SEMNUM,CMD,ARG\n            Calls the System V IPC function "semctl". You'll probably have\n            to say\n\n                use IPC::SysV;\n\n            first to get the correct constant definitions. If CMD is\n            IPC_STAT or GETALL, then ARG must be a variable which will hold\n            the returned semid_ds structure or semaphore value array.\n            Returns like "ioctl": the undefined value for error, ""0 but\n            true"" for zero, or the actual return value otherwise. The ARG\n            must consist of a vector of native short integers, which may be\n            created with "pack("s!",(0)x$nsem)". See also "SysV IPC" in\n            perlipc, "IPC::SysV", "IPC::Semaphore" documentation.
semget=    semget KEY,NSEMS,FLAGS\n            Calls the System V IPC function semget. Returns the semaphore\n            id, or the undefined value if there is an error. See also "SysV\n            IPC" in perlipc, "IPC::SysV", "IPC::SysV::Semaphore"\n            documentation.
semop=    semop KEY,OPSTRING\n            Calls the System V IPC function semop to perform semaphore\n            operations such as signalling and waiting. OPSTRING must be a\n            packed array of semop structures. Each semop structure can be\n            generated with "pack("s!3", $semnum, $semop, $semflag)". The\n            number of semaphore operations is implied by the length of\n            OPSTRING. Returns true if successful, or false if there is an\n            error. As an example, the following code waits on semaphore\n            $semnum of semaphore id $semid:\n\n                $semop = pack("s!3", $semnum, -1, 0);\n                die "Semaphore trouble: $!\\n" unless semop($semid, $semop);\n\n            To signal the semaphore, replace -1 with 1. See also "SysV IPC"\n            in perlipc, "IPC::SysV", and "IPC::SysV::Semaphore"\n            documentation.
send=    send SOCKET,MSG,FLAGS,TO\n    send SOCKET,MSG,FLAGS\n            Sends a message on a socket. Attempts to send the scalar MSG to\n            the SOCKET filehandle. Takes the same flags as the system call\n            of the same name. On unconnected sockets you must specify a\n            destination to send TO, in which case it does a C "sendto".\n            Returns the number of characters sent, or the undefined value if\n            there is an error. The C system call sendmsg(2) is currently\n            unimplemented. See "UDP: Message Passing" in perlipc for\n            examples.
setpgrp=    setpgrp PID,PGRP\n            Sets the current process group for the specified PID, 0 for the\n            current process. Will produce a fatal error if used on a machine\n            that doesn't implement POSIX setpgid(2) or BSD setpgrp(2). If\n            the arguments are omitted, it defaults to "0,0". Note that the\n            BSD 4.2 version of "setpgrp" does not accept any arguments, so\n            only "setpgrp(0,0)" is portable. See also "POSIX::setsid()".
setpriority=    setpriority WHICH,WHO,PRIORITY\n            Sets the current priority for a process, a process group, or a\n            user. (See setpriority(2).) Will produce a fatal error if used\n            on a machine that doesn't implement setpriority(2).
setsockopt=    setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL\n            Sets the socket option requested. Returns undefined if there is\n            an error. OPTVAL may be specified as "undef" if you don't want\n            to pass an argument.
shift=    shift ARRAY\n    shift   Shifts the first value of the array off and returns it,\n            shortening the array by 1 and moving everything down. If there\n            are no elements in the array, returns the undefined value. If\n            ARRAY is omitted, shifts the @_ array within the lexical scope\n            of subroutines and formats, and the @ARGV array at file scopes\n            or within the lexical scopes established by the "eval ''",\n            "BEGIN {}", "INIT {}", "CHECK {}", and "END {}" constructs.
shmctl=    shmctl ID,CMD,ARG\n            Calls the System V IPC function shmctl. You'll probably have to\n            say\n\n                use IPC::SysV;\n\n            first to get the correct constant definitions. If CMD is\n            "IPC_STAT", then ARG must be a variable which will hold the\n            returned "shmid_ds" structure. Returns like ioctl: the undefined\n            value for error, "0 but true" for zero, or the actual return\n            value otherwise. See also "SysV IPC" in perlipc and "IPC::SysV"\n            documentation.
shmget=    shmget KEY,SIZE,FLAGS\n            Calls the System V IPC function shmget. Returns the shared\n            memory segment id, or the undefined value if there is an error.\n            See also "SysV IPC" in perlipc and "IPC::SysV" documentation.
shmread=    shmread ID,VAR,POS,SIZE\n    shmwrite ID,STRING,POS,SIZE\n            Reads or writes the System V shared memory segment ID starting\n            at position POS for size SIZE by attaching to it, copying\n            in/out, and detaching from it. When reading, VAR must be a\n            variable that will hold the data read. When writing, if STRING\n            is too long, only SIZE bytes are used; if STRING is too short,\n            nulls are written to fill out SIZE bytes. Return true if\n            successful, or false if there is an error. shmread() taints the\n            variable. See also "SysV IPC" in perlipc, "IPC::SysV"\n            documentation, and the "IPC::Shareable" module from CPAN.
shmwrite=    shmwrite ID,STRING,POS,SIZE\n            Reads or writes the System V shared memory segment ID starting\n            at position POS for size SIZE by attaching to it, copying\n            in/out, and detaching from it. When reading, VAR must be a\n            variable that will hold the data read. When writing, if STRING\n            is too long, only SIZE bytes are used; if STRING is too short,\n            nulls are written to fill out SIZE bytes. Return true if\n            successful, or false if there is an error. shmread() taints the\n            variable. See also "SysV IPC" in perlipc, "IPC::SysV"\n            documentation, and the "IPC::Shareable" module from CPAN.
shutdown=    shutdown SOCKET,HOW\n            Shuts down a socket connection in the manner indicated by HOW,\n            which has the same interpretation as in the system call of the\n            same name.
sin=    sin EXPR\n    sin     Returns the sine of EXPR (expressed in radians). If EXPR is\n            omitted, returns sine of $_.
sleep=    sleep EXPR\n    sleep   Causes the script to sleep for EXPR seconds, or forever if no\n            EXPR. May be interrupted if the process receives a signal such\n            as "SIGALRM". Returns the number of seconds actually slept. You\n            probably cannot mix "alarm" and "sleep" calls, because "sleep"\n            is often implemented using "alarm".
socket=    socket SOCKET,DOMAIN,TYPE,PROTOCOL\n            Opens a socket of the specified kind and attaches it to\n            filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the\n            same as for the system call of the same name. You should "use\n            Socket" first to get the proper definitions imported. See the\n            examples in "Sockets: Client/Server Communication" in perlipc.
socketpair=    socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL\n            Creates an unnamed pair of sockets in the specified domain, of\n            the specified type. DOMAIN, TYPE, and PROTOCOL are specified the\n            same as for the system call of the same name. If unimplemented,\n            yields a fatal error. Returns true if successful.
sort=    sort SUBNAME LIST\n    sort BLOCK LIST\n    sort LIST\n            In list context, this sorts the LIST and returns the sorted list\n            value. In scalar context, the behaviour of "sort()" is\n            undefined.
splice=    splice ARRAY,OFFSET,LENGTH,LIST\n    splice ARRAY,OFFSET,LENGTH\n    splice ARRAY,OFFSET\n    splice ARRAY\n            Removes the elements designated by OFFSET and LENGTH from an\n            array, and replaces them with the elements of LIST, if any. In\n            list context, returns the elements removed from the array. In\n            scalar context, returns the last element removed, or "undef" if\n            no elements are removed. The array grows or shrinks as\n            necessary. If OFFSET is negative then it starts that far from\n            the end of the array. If LENGTH is omitted, removes everything\n            from OFFSET onward. If LENGTH is negative, removes the elements\n            from OFFSET onward except for -LENGTH elements at the end of the\n            array. If both OFFSET and LENGTH are omitted, removes\n            everything. If OFFSET is past the end of the array, perl issues\n            a warning, and splices at the end of the array.
sprintf=    sprintf FORMAT, LIST\n            Returns a string formatted by the usual "printf" conventions of\n            the C library function "sprintf". See below for more details and\n            see sprintf(3) or printf(3) on your system for an explanation of\n            the general principles.
sqrt=    sqrt EXPR\n    sqrt    Return the square root of EXPR. If EXPR is omitted, returns\n            square root of $_. Only works on non-negative operands, unless\n            you've loaded the standard Math::Complex module.
srand=    srand EXPR\n    srand   Sets the random number seed for the "rand" operator.
stat=    stat FILEHANDLE\n    stat EXPR\n    stat    Returns a 13-element list giving the status info for a file,\n            either the file opened via FILEHANDLE, or named by EXPR. If EXPR\n            is omitted, it stats $_. Returns a null list if the stat fails.\n            Typically used as follows:\n\n                ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,\n                   $atime,$mtime,$ctime,$blksize,$blocks)\n                       = stat($filename);\n\n            Not all fields are supported on all filesystem types. Here are\n            the meaning of the fields:\n\n              0 dev      device number of filesystem\n              1 ino      inode number\n              2 mode     file mode  (type and permissions)\n              3 nlink    number of (hard) links to the file\n              4 uid      numeric user ID of file's owner\n              5 gid      numeric group ID of file's owner\n              6 rdev     the device identifier (special files only)\n              7 size     total size of file, in bytes\n              8 atime    last access time in seconds since the epoch\n              9 mtime    last modify time in seconds since the epoch\n             10 ctime    inode change time in seconds since the epoch (*)\n             11 blksize  preferred block size for file system I/O\n             12 blocks   actual number of blocks allocated\n\n            (The epoch was at 00:00 January 1, 1970 GMT.)\n\n            (*) The ctime field is non-portable, in particular you cannot\n            expect it to be a "creation time", see "Files and Filesystems"\n            in perlport for details.
study=    study SCALAR\n    study   Takes extra time to study SCALAR ($_ if unspecified) in\n            anticipation of doing many pattern matches on the string before\n            it is next modified. This may or may not save time, depending on\n            the nature and number of patterns you are searching on, and on\n            the distribution of character frequencies in the string to be\n            searched--you probably want to compare run times with and\n            without it to see which runs faster. Those loops which scan for\n            many short constant strings (including the constant parts of\n            more complex patterns) will benefit most. You may have only one\n            "study" active at a time--if you study a different scalar the\n            first is "unstudied". (The way "study" works is this: a linked\n            list of every character in the string to be searched is made, so\n            we know, for example, where all the 'k' characters are. From\n            each search string, the rarest character is selected, based on\n            some static frequency tables constructed from some C programs\n            and English text. Only those places that contain this "rarest"\n            character are examined.)\n\n            For example, here is a loop that inserts index producing entries\n            before any line containing a certain pattern:\n\n                while (<>) {\n                    study;\n                    print ".IX foo\\n"       if /\\bfoo\\b/;\n                    print ".IX bar\\n"       if /\\bbar\\b/;\n                    print ".IX blurfl\\n"    if /\\bblurfl\\b/;\n                    # ...\n                    print;\n                }\n\n            In searching for "/\\bfoo\\b/", only those locations in $_ that\n            contain "f" will be looked at, because "f" is rarer than "o". In\n            general, this is a big win except in pathological cases. The\n            only question is whether it saves you more time than it took to\n            build the linked list in the first place.
substr=    substr EXPR,OFFSET,LENGTH,REPLACEMENT\n    substr EXPR,OFFSET,LENGTH\n    substr EXPR,OFFSET\n            Extracts a substring out of EXPR and returns it. First character\n            is at offset 0, or whatever you've set $[ to (but don't do\n            that). If OFFSET is negative (or more precisely, less than $[),\n            starts that far from the end of the string. If LENGTH is\n            omitted, returns everything to the end of the string. If LENGTH\n            is negative, leaves that many characters off the end of the\n            string.
symlink=    symlink OLDFILE,NEWFILE\n            Creates a new filename symbolically linked to the old filename.\n            Returns 1 for success, 0 otherwise. On systems that don't\n            support symbolic links, produces a fatal error at run time. To\n            check for that, use eval:\n\n                $symlink_exists = eval { symlink("",""); 1 };\n\n
syscall=    syscall LIST\n            Calls the system call specified as the first element of the\n            list, passing the remaining elements as arguments to the system\n            call. If unimplemented, produces a fatal error. The arguments\n            are interpreted as follows: if a given argument is numeric, the\n            argument is passed as an int. If not, the pointer to the string\n            value is passed. You are responsible to make sure a string is\n            pre-extended long enough to receive any result that might be\n            written into a string. You can't use a string literal (or other\n            read-only string) as an argument to "syscall" because Perl has\n            to assume that any string pointer might be written through. If\n            your integer arguments are not literals and have never been\n            interpreted in a numeric context, you may need to add 0 to them\n            to force them to look like numbers. This emulates the "syswrite"\n            function (or vice versa):\n\n                require 'syscall.ph';               # may need to run h2ph\n                $s = "hi there\\n";\n                syscall(&SYS_write, fileno(STDOUT), $s, length $s);\n\n            Note that Perl supports passing of up to only 14 arguments to\n            your system call, which in practice should usually suffice.
sysopen=    sysopen FILEHANDLE,FILENAME,MODE\n    sysopen FILEHANDLE,FILENAME,MODE,PERMS\n            Opens the file whose filename is given by FILENAME, and\n            associates it with FILEHANDLE. If FILEHANDLE is an expression,\n            its value is used as the name of the real filehandle wanted.\n            This function calls the underlying operating system's "open"\n            function with the parameters FILENAME, MODE, PERMS.
sysread=    sysread FILEHANDLE,SCALAR,LENGTH,OFFSET\n    sysread FILEHANDLE,SCALAR,LENGTH\n            Attempts to read LENGTH *characters* of data into variable\n            SCALAR from the specified FILEHANDLE, using the system call\n            read(2). It bypasses buffered IO, so mixing this with other\n            kinds of reads, "print", "write", "seek", "tell", or "eof" can\n            cause confusion because stdio usually buffers data. Returns the\n            number of characters actually read, 0 at end of file, or undef\n            if there was an error. SCALAR will be grown or shrunk so that\n            the last byte actually read is the last byte of the scalar after\n            the read.
sysseek=    sysseek FILEHANDLE,POSITION,WHENCE\n            Sets FILEHANDLE's system position *in bytes* using the system\n            call lseek(2). FILEHANDLE may be an expression whose value gives\n            the name of the filehandle. The values for WHENCE are 0 to set\n            the new position to POSITION, 1 to set the it to the current\n            position plus POSITION, and 2 to set it to EOF plus POSITION\n            (typically negative).
system=    system LIST\n    system PROGRAM LIST\n            Does exactly the same thing as "exec LIST", except that a fork\n            is done first, and the parent process waits for the child\n            process to complete. Note that argument processing varies\n            depending on the number of arguments. If there is more than one\n            argument in LIST, or if LIST is an array with more than one\n            value, starts the program given by the first element of the list\n            with arguments given by the rest of the list. If there is only\n            one scalar argument, the argument is checked for shell\n            metacharacters, and if there are any, the entire argument is\n            passed to the system's command shell for parsing (this is\n            "/bin/sh -c" on Unix platforms, but varies on other platforms).\n            If there are no shell metacharacters in the argument, it is\n            split into words and passed directly to "execvp", which is more\n            efficient.
syswrite=    syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET\n    syswrite FILEHANDLE,SCALAR,LENGTH\n    syswrite FILEHANDLE,SCALAR\n            Attempts to write LENGTH characters of data from variable SCALAR\n            to the specified FILEHANDLE, using the system call write(2). If\n            LENGTH is not specified, writes whole SCALAR. It bypasses\n            buffered IO, so mixing this with reads (other than sysread()),\n            "print", "write", "seek", "tell", or "eof" may cause confusion\n            because stdio usually buffers data. Returns the number of\n            characters actually written, or "undef" if there was an error.\n            If the LENGTH is greater than the available data in the SCALAR\n            after the OFFSET, only as much data as is available will be\n            written.
tell=    tell FILEHANDLE\n    tell    Returns the current position *in bytes* for FILEHANDLE, or -1 on\n            error. FILEHANDLE may be an expression whose value gives the\n            name of the actual filehandle. If FILEHANDLE is omitted, assumes\n            the file last read.
telldir=    telldir DIRHANDLE\n            Returns the current position of the "readdir" routines on\n            DIRHANDLE. Value may be given to "seekdir" to access a\n            particular location in a directory. Has the same caveats about\n            possible directory compaction as the corresponding system\n            library routine.
tie=    tie VARIABLE,CLASSNAME,LIST\n            This function binds a variable to a package class that will\n            provide the implementation for the variable. VARIABLE is the\n            name of the variable to be enchanted. CLASSNAME is the name of a\n            class implementing objects of correct type. Any additional\n            arguments are passed to the "new" method of the class (meaning\n            "TIESCALAR", "TIEHANDLE", "TIEARRAY", or "TIEHASH"). Typically\n            these are arguments such as might be passed to the "dbm_open()"\n            function of C. The object returned by the "new" method is also\n            returned by the "tie" function, which would be useful if you\n            want to access other methods in CLASSNAME.
time=    time    Returns the number of non-leap seconds since whatever time the\n            system considers to be the epoch (that's 00:00:00, January 1,\n            1904 for Mac OS, and 00:00:00 UTC, January 1, 1970 for most\n            other systems). Suitable for feeding to "gmtime" and\n            "localtime".
times=    times   Returns a four-element list giving the user and system times, in\n            seconds, for this process and the children of this process.
tr=    tr///   The transliteration operator. Same as "y///". See perlop.
truncate=    truncate FILEHANDLE,LENGTH\n    truncate EXPR,LENGTH\n            Truncates the file opened on FILEHANDLE, or named by EXPR, to\n            the specified length. Produces a fatal error if truncate isn't\n            implemented on your system. Returns true if successful, the\n            undefined value otherwise.
uc=    uc EXPR\n    uc      Returns an uppercased version of EXPR. This is the internal\n            function implementing the "\\U" escape in double-quoted strings.\n            Respects current LC_CTYPE locale if "use locale" in force. See\n            perllocale and perlunicode for more details about locale and\n            Unicode support. It does not attempt to do titlecase mapping on\n            initial letters. See "ucfirst" for that.
ucfirst=    ucfirst EXPR\n    ucfirst Returns the value of EXPR with the first character in uppercase\n            (titlecase in Unicode). This is the internal function\n            implementing the "\\u" escape in double-quoted strings. Respects\n            current LC_CTYPE locale if "use locale" in force. See perllocale\n            and perlunicode for more details about locale and Unicode\n            support.
umask=    umask EXPR\n    umask   Sets the umask for the process to EXPR and returns the previous\n            value. If EXPR is omitted, merely returns the current umask.
undef=    undef EXPR\n    undef   Undefines the value of EXPR, which must be an lvalue. Use only\n            on a scalar value, an array (using "@"), a hash (using "%"), a\n            subroutine (using "&"), or a typeglob (using <*>). (Saying\n            "undef $hash{$key}" will probably not do what you expect on most\n            predefined variables or DBM list values, so don't do that; see\n            delete.) Always returns the undefined value. You can omit the\n            EXPR, in which case nothing is undefined, but you still get an\n            undefined value that you could, for instance, return from a\n            subroutine, assign to a variable or pass as a parameter.\n            Examples:\n\n                undef $foo;\n                undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};\n                undef @ary;\n                undef %hash;\n                undef &mysub;\n                undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.\n                return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;\n                select undef, undef, undef, 0.25;\n                ($a, $b, undef, $c) = &foo;       # Ignore third value returned\n\n            Note that this is a unary operator, not a list operator.
unlink=    unlink LIST\n    unlink  Deletes a list of files. Returns the number of files\n            successfully deleted.
unpack=    unpack TEMPLATE,EXPR\n            "unpack" does the reverse of "pack": it takes a string and\n            expands it out into a list of values. (In scalar context, it\n            returns merely the first value produced.)\n\n            The string is broken into chunks described by the TEMPLATE. Each\n            chunk is converted separately to a value. Typically, either the\n            string is a result of "pack", or the bytes of the string\n            represent a C structure of some kind.
unshift=    unshift ARRAY,LIST\n            Does the opposite of a "shift". Or the opposite of a "push",\n            depending on how you look at it. Prepends list to the front of\n            the array, and returns the new number of elements in the array.
untie=    untie VARIABLE\n            Breaks the binding between a variable and a package. (See\n            "tie".) Has no effect if the variable is not tied.
use=    use Module VERSION LIST\n    use Module VERSION\n    use Module LIST\n    use Module\n    use VERSION\n            Imports some semantics into the current package from the named\n            module, generally by aliasing certain subroutine or variable\n            names into your package. It is exactly equivalent to\n\n                BEGIN { require Module; import Module LIST; }\n\n            except that Module *must* be a bareword.
utime=    utime LIST\n            Changes the access and modification times on each file of a list\n            of files. The first two elements of the list must be the\n            NUMERICAL access and modification times, in that order. Returns\n            the number of files successfully changed. The inode change time\n            of each file is set to the current time. This code has the same\n            effect as the "touch" command if the files already exist:\n\n                #!/usr/bin/perl\n                $now = time;\n                utime $now, $now, @ARGV;\n\n            If the first two elements of the list are "undef", then the\n            utime(2) function in the C library will be called with a null\n            second argument. On most systems, this will set the file's\n            access and modification times to the current time. (i.e.\n            equivalent to the example above.)\n\n                utime undef, undef, @ARGV;\n\n
values=    values HASH\n            Returns a list consisting of all the values of the named hash.\n            (In a scalar context, returns the number of values.) The values\n            are returned in an apparently random order. The actual random\n            order is subject to change in future versions of perl, but it is\n            guaranteed to be the same order as either the "keys" or "each"\n            function would produce on the same (unmodified) hash.
vec=    vec EXPR,OFFSET,BITS\n            Treats the string in EXPR as a bit vector made up of elements of\n            width BITS, and returns the value of the element specified by\n            OFFSET as an unsigned integer. BITS therefore specifies the\n            number of bits that are reserved for each element in the bit\n            vector. This must be a power of two from 1 to 32 (or 64, if your\n            platform supports that).
wantarray=    wantarray\n            Returns true if the context of the currently executing\n            subroutine is looking for a list value. Returns false if the\n            context is looking for a scalar. Returns the undefined value if\n            the context is looking for no value (void context).
warn=    warn LIST\n            Produces a message on STDERR just like "die", but doesn't exit\n            or throw an exception.
write=    write FILEHANDLE\n    write EXPR\n    write   Writes a formatted record (possibly multi-line) to the specified\n            FILEHANDLE, using the format associated with that file. By\n            default the format for a file is the one having the same name as\n            the filehandle, but the format for the current output channel\n            (see the "select" function) may be set explicitly by assigning\n            the name of the format to the $~ variable.
y=    y///    The transliteration operator. Same as "tr///". See perlop.
